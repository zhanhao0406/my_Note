# 通讯
---
## 通讯接口定义方式   

|话题(.msg文件)|服务(.srv文件)|动作(.action文件)|
|:--|:--|:--|
|# 通讯数据<br>int32 x<br>int32 y|# 请求数据<br>int64 a<br>int64 b<br>---<br># 应答数据<br>int64 sum|# 目标<br>bool enable<br>---<br># 结果<br>bool finish<br>---<br># 反馈<br>int32 state|

---
## 查看常用通讯接口   
路径：Other Locations/Computer/opt/ros/humble/share ----  (Then search: msg & srv ....)
Example:
* 查看系统目前所有的接口定义 `ros2 interface list`
* 查看话题<mark>msg</mark>通信的接口 `ros2 interface show sensor_msgs/msg/Image`
* 查看服务<mark>srv</mark>通信的接口 `ros2 interface show turtlesim/srv/Spawn`
* 查看动作<mark>action</mark>通信的接口 `ros2 interface show turtlesim/action/RotateAbsolute`
* 查看某功能包定义的所有通信接口 `ros2 interface package learning_interface`
---
 ## 9.0讲了srv文件的使用。本章再次回到learning_topic_cpp文件，讲述自定义.msg文件的通讯。
 路径Followed by: /learning_topic/learning_topic/interface_object_pub.py  
 <details>
<summary><mark>interface_object_pub.cpp全部代码</mark> </summary> 
  
```c++
/**
 * @file interface_object_pub.cpp
 * @brief 视觉处理节点：订阅图像 -> 检测红色物体 -> 发布坐标
 * @details 此节点是ROS2中“传感-处理-发布”模式的典型实现。
 *          1. 订阅者：持续接收 /image_raw 话题的图像数据。
 *          2. 处理器：使用OpenCV检测红色物体并计算其中心坐标。
 *          3. 发布者：将检测到的坐标通过 /object_position 话题发布出去。
 */

#include <memory>
#include <atomic>
#include <functional>

// ROS2核心库
#include "rclcpp/rclcpp.hpp"
// 图像消息类型
#include "sensor_msgs/msg/image.hpp"
// 自定义消息类型：目标位置
#include "learning_interface/msg/object_position.hpp"
// ROS-OpenCV图像转换
#include "cv_bridge/cv_bridge.h"
// OpenCV图像处理库
#include "opencv2/opencv.hpp"

// 用于占位符 _1，表示回调函数的第一个参数
using std::placeholders::_1;

/**
 * @class ImageProcessorPublisher
 * @brief 复合节点类：图像处理器 + 位置发布者
 *
 * 这个类同时管理两种ROS2通信实体：
 * - 一个图像订阅者，接收摄像头数据。
 * - 一个位置发布者，发布检测到的物体坐标。
 * 图像处理和坐标更新在同一个回调函数中完成，确保数据的实时性和一致性。
 */

 class ImageProcessorPublisher : public rclcpp::Node
{
public:
    /**
     * @brief 构造函数：初始化节点和所有通信接口
     */
    ImageProcessorPublisher() : Node("topic_webcam_sub")
    {
        // --- 1. 初始化红色检测的HSV阈值 ---
        // OpenCV中HSV范围：H(0-180), S(0-255), V(0-255)
        lower_red_ = cv::Scalar(0, 90, 128);    // 红色阈值下限
        upper_red_ = cv::Scalar(180, 255, 255); // 红色阈值上限

        // --- 2. 创建图像订阅者 ---
        // 订阅原始图像话题，队列大小为10（缓存10帧以防处理不及时）
        image_subscription_ = this->create_subscription<sensor_msgs::msg::Image>(
            "image_raw",
            10,
            std::bind(&ImageProcessorPublisher::image_callback, this, _1));

        // --- 3. 创建位置发布者 ---
        // 发布检测到的物体坐标，话题名为 object_position
        position_publisher_ = this->create_publisher<learning_interface::msg::ObjectPosition>(
            "object_position",
            10);

        // --- 4. 初始化坐标存储（原子操作，确保线程安全）---
        object_x_.store(0);
        object_y_.store(0);

        // --- 5. 打印启动信息 ---
        RCLCPP_INFO(this->get_logger(), "视觉处理节点已启动");
        RCLCPP_INFO(this->get_logger(), "  订阅：/image_raw");
        RCLCPP_INFO(this->get_logger(), "  发布：/object_position");
    }

private:
    /**
     * @brief 图像回调函数：处理每一帧图像
     * @param msg 接收到的图像消息（智能指针）
     *
     * 每当收到新图像时，ROS2自动调用此函数。
     * 处理流程：图像转换 -> 红色检测 -> 更新坐标 -> 发布坐标。
     */
    void image_callback(const sensor_msgs::msg::Image::SharedPtr msg)
    {
        // 1. 将ROS2图像消息转换为OpenCV格式
        cv_bridge::CvImagePtr cv_ptr;
        try
        {
            // 使用cv_bridge进行转换，"bgr8"指定了图像的色彩编码
            cv_ptr = cv_bridge::toCvCopy(msg, "bgr8");
        }
        catch (cv_bridge::Exception &e)
        {
            RCLCPP_ERROR(this->get_logger(), "cv_bridge转换失败: %s", e.what());
            return;
        }

        // 2. 获取OpenCV图像矩阵
        cv::Mat image = cv_ptr->image;

        // 3. 执行红色物体检测
        detect_red_object(image);

        // 4. 创建并发布位置消息
        auto position_msg = std::make_shared<learning_interface::msg::ObjectPosition>();
        position_msg->x = object_x_.load(); // 从原子变量读取x坐标
        position_msg->y = object_y_.load(); // 从原子变量读取y坐标

        // 5. 发布坐标消息
        position_publisher_->publish(*position_msg);

        // 6. 打印调试信息（可选，避免控制台输出过多）
        // RCLCPP_DEBUG(this->get_logger(), "发布坐标: x=%d, y=%d", position_msg->x, position_msg->y);
    }

    /**
     * @brief 红色物体检测函数
     * @param image 输入/输出图像。函数会在此图像上绘制检测结果。
     *
     * 使用OpenCV进行红色物体检测：
     * 1. 转换到HSV色彩空间
     * 2. 根据阈值创建红色掩膜
     * 3. 查找并过滤轮廓
     * 4. 计算最大轮廓的中心坐标
     * 5. 可视化显示结果
     */
    void detect_red_object(cv::Mat &image)
    {
        cv::Mat hsv_image, mask_red;
        std::vector<std::vector<cv::Point>> contours;

        // 步骤1: BGR -> HSV 转换
        cv::cvtColor(image, hsv_image, cv::COLOR_BGR2HSV);

        // 步骤2: 创建红色掩膜
        cv::inRange(hsv_image, lower_red_, upper_red_, mask_red);

        // 可选：形态学操作（去除噪声，连接断点）
        // cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
        // cv::morphologyEx(mask_red, mask_red, cv::MORPH_OPEN, kernel);
        // cv::morphologyEx(mask_red, mask_red, cv::MORPH_CLOSE, kernel);

        // 步骤3: 查找轮廓
        cv::findContours(mask_red, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

        int max_area = 0;
        cv::Rect best_rect;
        bool object_found = false;

        // 步骤4: 遍历轮廓，找到面积最大的红色物体
        for (const auto &contour : contours)
        {
            // 过滤掉太小的轮廓（噪声）
            if (contour.size() < 150)
                continue;

            cv::Rect rect = cv::boundingRect(contour);
            int area = rect.width * rect.height;

            // 选择面积最大的轮廓作为目标
            if (area > max_area)
            {
                max_area = area;
                best_rect = rect;
                object_found = true;
            }
        }

        // 步骤5: 如果找到目标，更新坐标并可视化
        if (object_found)
        {
            int center_x = best_rect.x + best_rect.width / 2;
            int center_y = best_rect.y + best_rect.height / 2;

            // 原子操作更新坐标（确保线程安全）
            object_x_.store(center_x);
            object_y_.store(center_y);

            // 可视化：在图像上绘制矩形框和中心点
            cv::rectangle(image, best_rect, cv::Scalar(0, 255, 0), 2); // 绿色矩形框
            cv::circle(image, cv::Point(center_x, center_y), 5, cv::Scalar(0, 0, 255), -1); // 红色中心点

            // 可选：添加文字标签
            cv::putText(image, 
                       "Target", 
                       cv::Point(best_rect.x, best_rect.y - 10),
                       cv::FONT_HERSHEY_SIMPLEX, 
                       0.5, 
                       cv::Scalar(0, 255, 0), 
                       1);
        }
        else
        {
            // 未检测到目标，坐标重置为0
            object_x_.store(0);
            object_y_.store(0);
        }

        // 步骤6: 显示处理后的图像
        cv::imshow("Red Object Detection", image);
        cv::waitKey(1); // 等待1毫秒，刷新显示窗口
    }

    // ========== 成员变量声明 ==========
    // ROS2通信对象
    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr image_subscription_;  // 图像订阅者
    rclcpp::Publisher<learning_interface::msg::ObjectPosition>::SharedPtr position_publisher_; // 位置发布者

    // 图像处理参数
    cv::Scalar lower_red_; // HSV阈值下限
    cv::Scalar upper_red_; // HSV阈值上限

    // 坐标存储（使用原子类型保证多线程安全）
    std::atomic<int> object_x_; // 物体X坐标
    std::atomic<int> object_y_; // 物体Y坐标
};

/**
 * @brief 主函数：节点入口点
 */
int main(int argc, char **argv)
{
    // 1. 初始化ROS2
    rclcpp::init(argc, argv);

    // 2. 创建节点对象并进入事件循环
    auto node = std::make_shared<ImageProcessorPublisher>();
    rclcpp::spin(node);

    // 3. 关闭ROS2，清理资源
    rclcpp::shutdown();

    // 4. 关闭所有OpenCV窗口
    cv::destroyAllWindows();

    return 0;
}

```

 </details>
 
---   

 路径Followed by: /learning_topic/learning_topic/interface_object_sub.py  
 <details>
<summary><mark>interface_object_sub.cpp全部代码</mark> </summary> 
  
```c++
/**
 * @file interface_object_sub.cpp
 * @brief 坐标订阅者节点：接收并显示目标位置
 * @details 此节点订阅 /object_position 话题，接收其他节点发布的物体坐标。
 *          这是ROS2中"关注点分离"架构的体现：一个节点负责处理，另一个节点负责消费结果。
 */

#include <memory>
#include <functional>

// ROS2核心库
#include "rclcpp/rclcpp.hpp"
// 自定义消息类型：目标位置
#include "learning_interface/msg/object_position.hpp"

// 用于占位符 _1
using std::placeholders::_1;

/**
 * @class PositionSubscriber
 * @brief 位置订阅者节点类
 *
 * 这个节点专门订阅坐标消息并打印结果，展示了ROS2中"消费者"节点的简单实现。
 */

class PositionSubscriber : public rclcpp::Node
{
public:
    /**
     * @brief 构造函数：初始化节点和订阅者
     */
    PositionSubscriber() : Node("interface_position_sub")
    {
        // 创建位置订阅者
        // 参数：消息类型，话题名，回调函数，队列大小
        position_subscription_ = this->create_subscription<learning_interface::msg::ObjectPosition>(
            "object_position",
            10,
            std::bind(&PositionSubscriber::position_callback, this, _1));

        // 打印启动信息
        RCLCPP_INFO(this->get_logger(), "坐标订阅节点已启动");
        RCLCPP_INFO(this->get_logger(), "  订阅：/object_position");
    }

private:
    /**
     * @brief 位置回调函数：处理接收到的坐标消息
     * @param msg 接收到的位置消息（智能指针）
     *
     * 每当有新坐标发布时，ROS2自动调用此函数。
     * 这里简单地将坐标打印到控制台，实际应用中可能进行更复杂的处理。
     */
    void position_callback(const learning_interface::msg::ObjectPosition::SharedPtr msg)
    {
        // 打印接收到的坐标
        RCLCPP_INFO(this->get_logger(), "目标位置: (%d, %d)", msg->x, msg->y);
        
        // 注意：这里使用 %d 而不是 %ld，因为ObjectPosition中的x和y是int32类型
    }

    // 成员变量：位置订阅者
    rclcpp::Subscription<learning_interface::msg::ObjectPosition>::SharedPtr position_subscription_;
};

/**
 * @brief 主函数：节点入口点
 */
int main(int argc, char **argv)
{
    // 1. 初始化ROS2
    rclcpp::init(argc, argv);

    // 2. 创建节点对象并进入事件循环
    auto node = std::make_shared<PositionSubscriber>();
    rclcpp::spin(node);

    // 3. 关闭ROS2
    rclcpp::shutdown();

    return 0;
}
```
 </details>
 
---   

之后需要在`CMakeLists.txt`中补充：  

```.txt
find_package(learning_interface REQUIRED)  # 自定义接口包


// 添加视觉处理发布者节点
add_executable(interface_object_pub
  src/interface_object_pub.cpp
)
// target_include_directories(interface_object_pub PRIVATE
//   ${OpenCV_INCLUDE_DIRS}
// )
ament_target_dependencies(interface_object_pub
  rclcpp
  sensor_msgs
  cv_bridge
  OpenCV
  learning_interface  # 必须链接！
)

// 添加位置订阅者节点
add_executable(interface_object_sub
  src/interface_object_sub.cpp
)
ament_target_dependencies(interface_object_sub
  rclcpp
  learning_interface  # 必须链接！
)

```
---
以及`package.xml`中需要有：  

```.xml
<depend>rclcpp</depend>
<depend>learning_interface</depend>  <!-- 自定义消息接口 -->
<depend>sensor_msgs</depend>        <!-- 仅interface_object_pub需要 -->
<depend>cv_bridge</depend>          <!-- 仅interface_object_pub需要 -->
<depend>opencv</depend>             <!-- 仅interface_object_pub需要 -->
```

---

最后   
`colcon build`   
`ros2 run usb_cam usb_cam_node_exe`  
`ros2 run learning_topic_cpp interface_object_pub`  
`ros2 run learning_topic_cpp interface_object_sub`
