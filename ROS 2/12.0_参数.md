# 参数
<mark>参数：机器人系统的全局字典</mark>

Example:  
turtlesim的背景修改  
`ros2 run turtlesim turtlesim_node `   
`ros2 run turtlesim turtle_teleop_key `   
`ros2 param list  //查看已有的参数列表`  
`ros2 param describe turtlesim background_b  //描述参数，定义，描述，限制等`   
`ros2 param get turtlesim background_b   //获取背景值`   
`ros2 param set turtlesim background_b 100  //修改背景值`  

#太复杂，配置文件的方式，做整体修改。#    
`ros2 param dump turtlesim    //打印该节点中的所有参数，到终端里面`   
`ros2 param dump turtlesim >> turtlesim.yaml    //重新定向保存。`   
在保存的文件中修改，然后使用   
`ros2 param load turtlesim turtlesim.yaml //加载新的值`  

---  

代码路径为 /learning_param_cpp/src/param_declare  

---

编译完成后，运行：  
`ros2 run learning_parameter_cpp param_declare`   
`ros2 param list`  
`ros2 param get param_declare robot_name  //查看robot 的名字`  
`ros2 param set param_declare robot_name turtle   //修改robot的名字为 turtle，发现无法外部修改。还叫代码中的名字。`  

---  

Example：不需要编译代码，实现参数变化。  
原路径Path: /learning_parameter/learning_parameter/param_object_detect.py  
新路径Path: /learning_parameter_cpp/src/prarm_object_detect.cpp   

<details>
<summary> <mark> 展开代码param_object_detect.cpp </mark></summary>  

```c++
#include <memory>
#include <vector>
#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/image.hpp"
#include "cv_bridge/cv_bridge.h"
#include "opencv2/opencv.hpp"

using std::placeholders::_1;

class ParamImageSubscriber : public rclcpp::Node
{
public:
    // 构造函数
    ParamImageSubscriber() : Node("param_object_detect")
    {
        // 创建图像订阅者
        image_subscription_ = this->create_subscription<sensor_msgs::msg::Image>(
            "image_raw", 10, std::bind(&ParamImageSubscriber::image_callback, this, _1));
        
        // 声明参数（对应Python的declare_parameter）
        this->declare_parameter("red_h_upper", 0);   // 参数名，默认值
        this->declare_parameter("red_h_lower", 0);
        
        RCLCPP_INFO(this->get_logger(), "参数化检测节点已启动");
    }

private:
    // 成员变量
    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr image_subscription_;
    
    // 固定的HSV阈值部分
    const int red_s_lower = 90;   // S通道下限
    const int red_s_upper = 255;  // S通道上限
    const int red_v_lower = 128;  // V通道下限
    const int red_v_upper = 255;  // V通道上限

    // 图像回调函数
    void image_callback(const sensor_msgs::msg::Image::SharedPtr msg)
    {
        // 将ROS图像消息转换为OpenCV图像
        cv_bridge::CvImagePtr cv_ptr;
        try {
            cv_ptr = cv_bridge::toCvCopy(msg, "bgr8");
        } catch (cv_bridge::Exception &e) {
            RCLCPP_ERROR(this->get_logger(), "图像转换失败: %s", e.what());
            return;
        }
        
        // 调用检测函数
        object_detect(cv_ptr->image);
    }
    
    // 目标检测函数
    void object_detect(cv::Mat &image)
    {
        // 获取参数值（对应Python的get_parameter）
        int red_h_upper = this->get_parameter("red_h_upper").as_int();
        int red_h_lower = this->get_parameter("red_h_lower").as_int();
        
        // 输出参数值到日志
        RCLCPP_INFO(this->get_logger(), "Get Red H Upper: %d, Lower: %d", red_h_upper, red_h_lower);
        
        // 创建HSV阈值
        cv::Scalar lower_red(red_h_lower, red_s_lower, red_v_lower);
        cv::Scalar upper_red(red_h_upper, red_s_upper, red_v_upper);
        
        // OpenCV处理流程
        cv::Mat hsv_img, mask_red;
        std::vector<std::vector<cv::Point>> contours;
        
        // BGR转HSV
        cv::cvtColor(image, hsv_img, cv::COLOR_BGR2HSV);
        
        // 根据阈值创建掩膜
        cv::inRange(hsv_img, lower_red, upper_red, mask_red);
        
        // 查找轮廓
        cv::findContours(mask_red, contours, cv::RETR_LIST, cv::CHAIN_APPROX_NONE);
        
        // 处理每个轮廓
        for (const auto& cnt : contours) {
            // 过滤小轮廓
            if (cnt.size() < 150) {
                continue;
            }
            
            // 获取外接矩形
            cv::Rect rect = cv::boundingRect(cnt);
            int x = rect.x;
            int y = rect.y;
            int w = rect.width;
            int h = rect.height;
            
            // 绘制轮廓
            std::vector<std::vector<cv::Point>> draw_cnt = {cnt};
            cv::drawContours(image, draw_cnt, -1, cv::Scalar(0, 255, 0), 2);
            
            // 绘制中心点
            cv::circle(image, cv::Point(int(x + w/2), int(y + h/2)), 5, cv::Scalar(0, 255, 0), -1);
        }
        
        // 显示图像
        cv::imshow("object", image);
        cv::waitKey(10);
    }
};

// 主函数
int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<ParamImageSubscriber>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    cv::destroyAllWindows();
    return 0;
}
```

</details>
---  

CMakeLists 修改：
```cmake
# 在 find_package 部分确保有以下依赖
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(sensor_msgs REQUIRED)    # 图像消息
find_package(cv_bridge REQUIRED)      # ROS-OpenCV转换
find_package(OpenCV REQUIRED)         # OpenCV库

# 添加参数化检测节点的可执行文件
add_executable(param_object_detect
  src/param_object_detect.cpp
)

# 为节点链接依赖库
ament_target_dependencies(param_object_detect
  rclcpp
  sensor_msgs
  cv_bridge
  OpenCV
)

# 可选：添加OpenCV头文件路径（某些系统需要）
target_include_directories(param_object_detect PRIVATE
  ${OpenCV_INCLUDE_DIRS}
)

# 在install部分添加这个节点
install(TARGETS
  # 你其他的可执行文件...
  param_object_detect                 # 添加这一行
  DESTINATION lib/${PROJECT_NAME}
)
```

package.xml 修改：
```xml
<!-- 必须有的依赖 -->
<depend>rclcpp</depend>

<!-- 图像处理相关依赖（这个节点需要的） -->
<depend>sensor_msgs</depend>
<depend>cv_bridge</depend>
<depend>opencv</depend>
<!-- 注意：如果你的learning_interface包定义了其他消息，也需要添加 -->
<!-- <depend>learning_interface</depend> -->
```
---  

编译完成后运行：  
`ros2 run usb_cam usb_cam_node_exe`  
`ros2 run learning_parameter_cpp param_object_detect`  
然后检测功能：  
`ros2 param list /param_object_detect     # 查看所有参数`   
```bash
# 在节点运行时，可以动态查看和修改参数
# 获取参数当前值
ros2 param get /param_object_detect red_h_lower
ros2 param get /param_object_detect red_h_upper

# 修改参数值（例如调整红色检测范围）
ros2 param set /param_object_detect red_h_lower 10
ros2 param set /param_object_detect red_h_upper 30
```



