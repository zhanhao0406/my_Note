# 服务通信

|客户端 Client|服务端 Server|   
|---|---|  
|* 编程接口初始化|* 创建接口初始化|
|* 创建节点并初始化|* 创建节点并初始化|
|* 创建客户端对象|* 创建服务器端对象|
|* 创建并发送请求数据|* 通过回调函数处进行服务|
|* 等待服务器端应答数据|* 向客户端反馈应答结果|
|* 销毁节点并关闭接口|* 销毁节点并关闭接口|  

---

Followed by /learning_service/learning_service/service_object_server.py  
<details>
<summary><mark>C++版本的service_object_server</mark></summary>  
  
```c++  
/**
 * @file service_object_server.cpp
 * @brief 高级例程：视觉检测与服务
 * @details 本节点实现了一个复杂的ROS2节点，它同时具备两种能力：
 *          1. 订阅者：订阅 /image_raw 话题，使用OpenCV实时检测图像中的红色物体，并计算其中心坐标。
 *          2. 服务端：提供 /get_target_position 服务。当客户端请求时，返回最近一次检测到的红色物体坐标。
 *          相当于将一个持续运行的“眼睛”（订阅者）和一个按需应答的“向导”（服务端）结合在一个程序中。
 */
#include <memory>
#include <atomic> // 用于线程安全的变量
#include <functional> // std::bind

// ROS2 核心库
#include "rclcpp/rclcpp.hpp"
// 图像消息类型
#include "sensor_msgs/msg/image.hpp"
// 自定义服务接口
#include "learning_interface/srv/get_object_position.hpp"
// OpenCV 库
#include "opencv2/opencv.hpp"
// ROS2与OpenCV图像转换桥接库
#include "cv_bridge/cv_bridge.h"

// 使用chrono字面量，例如 50ms
using namespace std::chrono_literals;

/**
 * @class ImageSubscriberServer
 * @brief 复合功能节点类：图像订阅者 + 位置服务端
 *
 * 继承自 rclcpp::Node。此类封装了所有逻辑：
 * - 在构造函数中创建图像订阅者和位置服务。
 * - 图像回调函数持续处理视频帧并更新物体坐标。
 * - 服务回调函数响应客户端请求，返回存储的坐标。
 */

class ImageSubscriberServer : public rclcpp::Node
{
public:
    /*
     * 初始化顺序：
     * 1. 初始化ROS2节点。
     * 2. 定义HSV阈值（用于红色检测）。
     * 3. 创建图像订阅者。
     * 4. 创建位置查询服务。
     * 5. 初始化原子坐标变量（保证多线程安全访问）。
     */
    ImageSubscriberServer (): Node("service_object_server")
    {
        // --- 1. 初始化HSV阈值（红色范围）
        lower_red_ = cv::Scalar(0, 90, 128);    // 下限
        upper_red_ = cv::Scalar(180, 255, 255); // 上限
        // --- 2. 创建图像订阅者 ---参数：消息类型，话题名，回调函数，队列长度
        subscription_ = this->create_subscription<sensor_msgs::msg::Image>(
            "image_raw",10,std::bind(&ImageSubscriberServer::image_callback,this,std::placeholders::_1));
        // --- 3. 创建位置服务 --- 参数：服务接口类型，服务名，回调函数
        service_ = this->create_service<learning_interface::srv::GetObjectPosition>(
            "get_target_position",std::bind(&ImageSubscriberServer::position_service_callback,this,std::placeholders::_1,std::placeholders::_2));
        // --- 4. 初始化坐标 ---
        // 使用原子变量确保在图像回调（可能运行在一个线程）和服务回调（运行在另一个线程）中安全读写。
        object_x_.store(0);
        object_y_.store(0);

        RCLCPP_INFO(this->get_logger(),"Vision Service Node has started.");
        RCLCPP_INFO(this->get_logger(),"订阅话题：/image_raw");
        RCLCPP_INFO(this->get_logger(), "  提供服务：/get_target_position");
    
    }

private:
    // ==================== 成员函数 ====================
    /**
     * @brief 图像话题回调函数
     * @param msg 收到的图像消息智能指针
     * 每当有新的图像帧到达时，ROS2会调用此函数。
     * 流程：转换图像 -> 检测红色物体 -> 更新内部坐标。
     */
    void image_callback(const sensor_msgs::msg::Image::SharedPtr msg)
    {
        // 将ROS2图像消息转换为OpenCV图像矩阵
        cv_bridge::CvImagePtr cv_ptr;
        try{
            cv_ptr = cv_bridge::toCvCopy(msg,sensor_msgs::image_encodings::BGR8);
        } catch (cv_bridge::Exception &e){
            RCLCPP_ERROR(this->get_logger(),"cv_bridge图像转换异常: %s",e.what());
            return;
        }
        // 调用检测函数处理图像
        detect_and_update(cv_ptr->image);
    }


    /**
     * @brief 检测红色物体并更新坐标
     * @param image 输入输出图像。函数会在此图像上绘制轮廓和中心点。
     * 核心图像处理函数。执行以下OpenCV操作：
     * 1. BGR转HSV色彩空间。
     * 2. 根据阈值创建红色掩膜。
     * 3. 查找轮廓。
     * 4. 过滤小面积噪声。
     * 5. 计算最大轮廓的中心并更新坐标。
     * 6. 可视化显示。
     */
    void detect_and_update(cv::Mat &image){
         cv::Mat hsv_image, mask_red;
        std::vector<std::vector<cv::Point>> contours;

        // 1. 转换到HSV色彩空间（对颜色识别更鲁棒）
        cv::cvtColor(image, hsv_image, cv::COLOR_BGR2HSV);
        // 2. 创建红色掩膜（二值图像，红色区域为白色）
        cv::inRange(hsv_image, lower_red_, upper_red_, mask_red);

        // 可选：进行形态学操作（开运算去噪，闭运算填补空洞）
        // cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5,5));
        // cv::morphologyEx(mask_red, mask_red, cv::MORPH_OPEN, kernel);

        // 3. 在掩膜中查找轮廓
        cv::findContours(mask_red, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

        int max_area = 0;
        cv::Rect best_rect;
        bool found = false;

        // 4. 遍历所有轮廓，找出面积最大的那个（假设最大的红色物体是我们的目标）
        for (const auto &contour : contours)
        {
            if (contour.size() < 150) // 轮廓点数太少，视为噪声
                continue;

            cv::Rect rect = cv::boundingRect(contour);
            int area = rect.width * rect.height;
            if (area > max_area)
            {
                max_area = area;
                best_rect = rect;
                found = true;
            }
        }

        // 5. 如果找到目标，更新坐标
        if (found)
        {
            int center_x = best_rect.x + best_rect.width / 2;
            int center_y = best_rect.y + best_rect.height / 2;

            // 原子操作更新坐标，确保服务回调读取时数据完整
            object_x_.store(center_x);
            object_y_.store(center_y);

            // 6. 可视化：在图像上绘制轮廓和中心点
            cv::rectangle(image, best_rect, cv::Scalar(0, 255, 0), 2); // 绿色框
            cv::circle(image, cv::Point(center_x, center_y), 5, cv::Scalar(0, 0, 255), -1); // 红色中心点
            cv::putText(image, "Target", cv::Point(best_rect.x, best_rect.y - 10),
                        cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0), 1);
        }
        else
        {
            // 未找到目标，坐标重置为0
            object_x_.store(0);
            object_y_.store(0);
        }

        // 7. 显示处理后的图像
        cv::imshow("Object Detection", image);
        cv::waitKey(1); // 等待1毫秒，刷新显示窗口
    }


     /**
     * @brief 位置服务回调函数
     * @param request  服务请求的共享指针
     * @param response 服务响应的共享指针
     *
     * 当客户端调用 /get_target_position 服务时，ROS2会调用此函数。
     * 根据请求中的 get 字段，决定是否返回检测到的坐标。
     */
    void position_service_callback(const std::shared_ptr<learning_interface::srv::GetObjectPosition::Request> request,
        std::shared_ptr<learning_interface::srv::GetObjectPosition::Response> response){
        
        if(request->get){
            // 读取原子变量存储的最新坐标
            response->x = object_x_.load();
            response->y = object_y_.load();
            RCLCPP_INFO(this->get_logger(),"服务被调用：返回坐标 x=%d, y=%d",response->x,response->y);
        } else{
            // 无效请求，返回零值
            response->x = 0;
            response->y = 0;
            RCLCPP_WARN(this->get_logger(), "服务被调用：收到无效请求 (get=false)");   
        }
    }


// ==================== 成员变量 ====================
    // ROS2 通信对象 --- 1. 图像订阅者; 2. 位置服务
    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr subscription_;
    rclcpp::Service<learning_interface::srv::GetObjectPosition>::SharedPtr service_;
    
    // 图像处理相关 --- 1. HSV 下限 2. HSV 上限
    cv::Scalar lower_red_;
    cv::Scalar upper_red_;

    // 坐标存储（原子操作，保证线程安全）
    std::atomic<int> object_x_;
    std::atomic<int> object_y_;


};

int main(int argc, char *argv[]){
    // 1. 初始化ROS2客户端库，解析命令行参数
    rclcpp::init(argc, argv);

    // 2. 创建节点对象并进入自旋（事件循环）
    auto node = std::make_shared<ImageSubscriberServer>();
    rclcpp::spin(node);

    // 3. 关闭ROS2，程序退出
    rclcpp::shutdown();

    // // 4. 销毁所有OpenCV窗口
    // cv::destroyAllWindows();
    // return 0;
}

```
</details>

---
Followed by /learning_service/learning_service/service_object_client.py 
<details>
<summary><mark>C++版本的service_object_client</mark></summary>  

```c++
/**
 * @file service_object_client.cpp
 * @brief 高级例程：服务客户端
 * @details 此客户端节点调用 /get_target_position 服务，获取视觉节点检测到的目标坐标。
 *          它演示了如何异步调用服务并等待结果。
 */

 #include<memory>
 #include "rclcpp/rclcpp.hpp"
 #include "learning_interface/srv/get_object_position.hpp"

using namespace std::chrono_literals;

/**
 * @brief 主函数
 *
 * 该客户端不定义自己的节点类，所有逻辑在 main 函数中完成。
 * 流程：初始化 -> 创建节点和客户端 -> 等待服务上线 -> 发送请求 -> 等待响应 -> 处理结果。
 */

int main(int argc,char * argv[]){
    rclcpp::init(argc, argv);

    // 2. 创建客户端节点
    auto node = std::make_shared<rclcpp::Node>("service_object_client");

    // 3. 创建服务客户端
    // 模板参数：服务接口类型
    // 函数参数：服务名称（必须与服务端发布的名称完全一致）
    auto client = node->create_client<learning_interface::srv::GetObjectPosition>("get_target_position");
    RCLCPP_INFO(node->get_logger(), "Waiting for server be online...");

    // 4. 阻塞等待，直到服务端上线（每隔1秒检查一次）
    while(!client->wait_for_service(1s)){
        // 检查用户是否按下了 Ctrl+C（rclcpp::ok() 返回 false）
        if(!rclcpp::ok()){
            RCLCPP_INFO(node->get_logger(), "等待服务时被用户中断");
            return 1;
        }
        RCLCPP_INFO(node->get_logger(), "服务不可用，继续等待...");
    }
    RCLCPP_INFO(node->get_logger(), "Service is online now..");

    // 5. 创建并填充请求数据
    auto request = std::make_shared<learning_interface::srv::GetObjectPosition::Request>();
    request->get = true;  // 设置为 true 以请求有效坐标

    // 6. 异步发送请求
    // 注意：async_send_request 立即返回一个 future 对象，不会阻塞。
    auto future_result = client->async_send_request(request);
    RCLCPP_INFO(node->get_logger(), "坐标请求已发送，等待响应...");

    // 7. 同步等待，直到收到服务端的响应
    // spin_until_future_complete 会阻塞当前线程，但处理接收到的消息，直到 future 完成。 // 设置5秒超时
    auto spin_result = rclcpp::spin_until_future_complete(node, future_result, 5s);  

    // 8. 根据等待结果处理响应
    if(spin_result == rclcpp::FutureReturnCode::SUCCESS){
        // 成功收到响应,获取响应结果
        auto response = future_result.get();
        RCLCPP_INFO(node->get_logger(), "服务调用成功！");
        RCLCPP_INFO(node->get_logger(), "目标物体坐标为: x = %d, y = %d", response->x, response->y);

    } else {
        // 所有未成功的情况（超时、中断等）都进入这里
        RCLCPP_INFO(node->get_logger(), " Fail to use server..");
        // RCLCPP_ERROR(node->get_logger(), "服务调用失败 (错误码：%d)。", static_cast<int>(spin_result));
    }

    // 9. 清理并退出
    rclcpp::shutdown();
    return 0;
}
```
</details>

---
CMakeLists.txt 需要添加:
```txt
find_package(rclcpp REQUIRED)
find_package(learning_interface REQUIRED)

find_package(std_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)  # 新增：图像消息
find_package(cv_bridge REQUIRED)    # 新增：ROS-OpenCV桥接
find_package(OpenCV REQUIRED)       # 新增：OpenCV库

# 添加服务端可执行文件
add_executable(service_object_server src/service_object_server.cpp)
# 链接服务端依赖库
ament_target_dependencies(service_object_server rclcpp learning_interface rclcpp sensor_msgs cv_bridge OpenCV)

# 添加客户端可执行文件
add_executable(service_object_client src/service_object_client.cpp)
# 链接客户端依赖库
ament_target_dependencies(service_object_client rclcpp learning_interface)

install(TARGETS
  service_adder_server
  service_adder_client
  service_object_server
  service_object_client
  DESTINATION lib/${PROJECT_NAME})
```
---
package.xml中需要添加：
```xml 
  <!-- 新增依赖 -->
  <depend>rclcpp</depend>
  <depend>sensor_msgs</depend>
  <depend>cv_bridge</depend>
  <depend>opencv</depend>
```

---

额外的测试操作：
1. `ros2 run usb_cam usb_cam_node_ext //打开摄像头`
2. `ros2 run learning_service_cpp service_object_server // 激活服务端`
3. `ros2 run learning_service_cpp service_object_client // 打开话题请求客户端`

以及：  
* `ros2 service list //查看有哪些供使用的服务`       
* `ros2 service type /get_target_position //服务的接口类型`    
* `ros2 service call /get_target_position learning_interface/srv/GetObjectPosition "get: True" //用命令行实现服务请求`   
   

