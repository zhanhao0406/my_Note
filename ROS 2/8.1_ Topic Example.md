# Topic Example. (C++ Version)
---
## 结合7_节点中的红色检测例子   
*总位置位于 /learning_topic_cpp 中*    
<mark>**Publisher**</mark>
"Referred to /learning_topic/learning_topic/topic_webcam_pub.py"

<details>
<summary><mark>展示Publisher部分代码</mark></summary>   
  
```c++
#include <memory>
#include <chrono>
#include <functional>

#include "rclcpp/rclcpp.hpp"                    // ROS2 C++核心库
#include "sensor_msgs/msg/image.hpp"            // 图像消息类型
#include "cv_bridge/cv_bridge.h"                // ROS-OpenCV转换
#include "opencv2/opencv.hpp"                   // OpenCV库

using namespace std::chrono_literals;


class WebCamPublisher : public rclcpp::Node
{
public:
    WebCamPublisher() : Node("topic_webcam_pub")
    {
        // 创建发布者，发布到 image_raw 话题，队列大小为10;（消息类型、话题名、队列长度）
        publisher_ = this->create_publisher<sensor_msgs::msg::Image>("image_raw",10);
        
        // 创建定时器，每100ms（0.1秒）触发一次回调;定时执行回调函数
        timer_ = this->create_wall_timer(100ms,std::bind(&WebCamPublisher::timer_callback,this));
        // 打开摄像头（设备号0通常是默认摄像头）
        cap_.open(0);
        
        // 检查摄像头是否成功打开
        if (!cap_.isOpened()) {
            RCLCPP_ERROR(this->get_logger(), "无法打开摄像头！");
            //throw std::runtime_error("无法打开摄像头");
        }
        else{
            RCLCPP_INFO(this->get_logger(),"摄像头发布者节点已启动");
        }
        
        
        // // 释放摄像头资源
        // ~WebCamPublisher()
        // if (cap_.isOpened()) {
        //     cap_.release();
        // }
        // RCLCPP_INFO(this->get_logger(), "摄像头发布者节点已关闭");
    }

private:
    void timer_callback()
    {
        cv::Mat frame;

        // 从摄像头读取一帧
        if(cap_.read(frame)){
            
            //auto now = this->now();

            // 使用 cv_bridge 将 OpenCV 图像转换为 ROS2 图像消息
            // 注意：ROS2 Humble 版本的 cv_bridge API 与之前版本有所不同
            auto msg = cv_bridge::CvImage(std_msgs::msg::Header(),"bgr8",frame).toImageMsg();

            //  // 设置消息的时间戳
            //msg->header.stamp = now;
            ///msg->header.frame_id = "camera_frame";

            // 输出日志信息
            RCLCPP_INFO(this->get_logger(),"发布视频帧");

            // 发布图像消息
            publisher_->publish(*msg);
            
        }
    }
    
    // ROS2 发布者（智能指针）
    rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr publisher_;
    // ROS2 定时器（智能指针）
    rclcpp::TimerBase::SharedPtr timer_;
    // OpenCV 视频捕获对象
    cv::VideoCapture cap_;
};

int main(int argc, char * argv[]){

    // 初始化 ROS2
    rclcpp::init(argc,argv);

    rclcpp::spin(std::make_shared<WebCamPublisher>());  

    rclcpp::shutdown();

}
```
</details>

---
<mark>**Subscriber**</mark>
"Referred to /learning_topic/learning_topic/topic_webcam_sub.py"
<details>
<summary><mark>展示Subscriber部分代码</mark></summary>   

```c++
#include <memory>
#include <vector> //用于存储轮廓


#include "rclcpp/rclcpp.hpp"          // ROS2 C++接口库
#include "sensor_msgs/msg/image.hpp"  // 图像消息类型
#include "cv_bridge/cv_bridge.h"      // ROS-OpenCV转换
#include "opencv2/opencv.hpp"         // OpenCV库

using std::placeholders::_1;

class WebCamSubscriber : public rclcpp::Node
{
public:
    // ROS2节点父类初始化    
    WebCamSubscriber() : Node("topic_webcam_sub"){
        // 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度）
        subscription_ = this->create_subscription<sensor_msgs::msg::Image>(
            "image_raw",10,std::bind(&WebCamSubscriber::image_callback,this,_1));
           
        // C++中使用 cv::Scalar 定义HSV阈值，对应Python的np.array
        // 格式为 (H, S, V)，注意OpenCV中H范围是0-180
        lower_red_ = cv::Scalar(0,90,128);
        higher_red_ = cv::Scalar(180,255,255);
        
    }

private:
    // 创建回调函数，执行收到话题消息后对数据的处理
    void image_callback(const sensor_msgs::msg::Image::SharedPtr  msg)
    {
        RCLCPP_INFO(this->get_logger(),"接收到视频帧");

        auto cv_image_ptr = cv_bridge::toCvCopy(msg,"bgr8");

        // 将ROS图像消息转换为OpenCV图像
        cv::Mat image = cv_image_ptr ->image;
        object_detect(image);
        // 显示图像
        cv::waitKey(10);
    }

     // 红色物体检测函数，对应Python中的 object_detect 方法
    void object_detect(cv::Mat &image) {
        cv::Mat hsv_img;
        cv::Mat mask_red;
        std::vector<std::vector<cv::Point>> contours;
        
        // 1. BGR转HSV (与Python的 cv2.COLOR_BGR2HSV 对应)
        cv::cvtColor(image, hsv_img, cv::COLOR_BGR2HSV);
        
        // 2. 根据阈值创建红色掩膜 (与Python的 cv2.inRange 对应)
        cv::inRange(hsv_img, lower_red_, higher_red_, mask_red);
        
        // 3. 查找轮廓 
        // 注意：C++的findContours参数与Python略有不同
        cv::findContours(mask_red, contours, cv::RETR_LIST, cv::CHAIN_APPROX_NONE);
        
        // 4. 遍历轮廓并处理
        for (const auto& cnt : contours) {
            // 过滤小轮廓：Python中是 cnt.shape[0] < 150，这里用轮廓点数
            if (cnt.size() < 150) {
                continue;
            }
            
            // 获取外接矩形
            cv::Rect rect = cv::boundingRect(cnt);
            int x = rect.x;
            int y = rect.y;
            int w = rect.width;
            int h = rect.height;
            
            // 绘制轮廓 (绿色，厚度2)
            cv::drawContours(image, std::vector<std::vector<cv::Point>>{cnt}, -1, cv::Scalar(0, 255, 0), 2);
            
            // 绘制中心点
            cv::circle(image, cv::Point(int(x + w/2), int(y + h/2)), 5, cv::Scalar(0, 255, 0), -1);

            cv::imshow("摄像头图像", image);
        }
    
    }
    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr subscription_;

    cv::Scalar lower_red_;
    cv::Scalar higher_red_;

};

int main(int argc, char * argv[]){

    rclcpp::init(argc,argv);

    rclcpp::spin(std::make_shared<WebCamSubscriber>());

    rclcpp::shutdown();

}
```
</details>

---
*此外，还需要对CMakeLists.txt 以及 package.xml 中进行修改，再进行编译*  
<mark>**CMakeLists.txt**</mark>
```txt
# 新增：摄像头相关的依赖
find_package(sensor_msgs REQUIRED)
find_package(cv_bridge REQUIRED)
find_package(OpenCV REQUIRED)

# 新增：摄像头发布者节点
add_executable(topic_webcam_pub src/topic_webcam_pub.cpp)
ament_target_dependencies(topic_webcam_pub rclcpp std_msgs cv_bridge OpenCV)
# 新增：摄像头订阅者节点
add_executable(topic_webcam_sub src/topic_webcam_sub.cpp)
ament_target_dependencies(topic_webcam_sub rclcpp std_msgs cv_bridge OpenCV)

install(TARGETS
  topic_helloworld_pub
  topic_helloworld_sub
  topic_webcam_pub    # 新增
  topic_webcam_sub    # 新增
  DESTINATION lib/${PROJECT_NAME})
```
---
<mark>**package.xml**</mark>   
```xml
  <!-- 新增依赖 -->
  <depend>sensor_msgs</depend>
  <depend>cv_bridge</depend>
  <depend>opencv</depend>
```
---
**最后需要重新编译，即可运行**   
`cd ~/dev_ws`    
`colcon build --packages-select learning_topic_cpp`   
`source install/setup.bash  #如果没有bashrc过`   

之后就可以运行发布者，以及订阅者    
`ros2 run learning_topic_cpp topic_webcam_pub`    
`ros2 run learning_topic_cpp topic_webcam_sub`   

然后测试话题消息之类的。   
`ros2 topic list`  
`ros2 topic info /image_raw`   
`ros2 topic bw /image_raw  #查看带宽`   
`ros2 topic echo /image_raw  #详细数据`    
 
`rqt_graph  #查看节点情况`
