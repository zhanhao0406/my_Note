# 动作  
---
action 文件的编写应该为：
```
bool enable     # 定义动作的目标，表示动作开始的指令
---
bool finish     # 定义动作的结果，表示是否成功执行
---
int32 state     # 定义动作的反馈，表示当前执行到的位置
```

---
.action 文件    
路径： /learning_action_cpp  
<details>
  <summary> <mark>全部带注释action_move_server代码</mark></summary>  

```c++
/***
 * @file action_move_server.cpp
 * @brief ROS2动作示例 - 圆周运动动作服务器
 * @details 
 * Action是ROS2中用于长时间运行任务的通信机制，结合了Topic（持续反馈）
 * 和Service（最终结果）的优点。服务器接收客户端的目标请求，执行圆周运动
 * 模拟，并周期性发送进度反馈，最后返回执行结果。
 * 
 * 执行流程：
 * 1. 创建动作服务器，监听"move_circle"动作
 * 2. 客户端发送目标后，服务器验证并接受
 * 3. 在新线程中执行圆周运动（0°→360°，每步30°）
 * 4. 每步发布进度反馈（当前角度）
 * 5. 完成后返回成功结果
 ***/

#include <iostream>
#include <thread>          // 用于创建独立执行线程
#include <chrono>          // 用于时间控制（休眠）

#include "rclcpp/rclcpp.hpp"                          // ROS2 C++接口库
#include "rclcpp_action/rclcpp_action.hpp"            // ROS2 动作类
#include "learning_interface/action/move_circle.hpp"  // 自定义的圆周运动接口

using namespace std;

/**
 * @class MoveCircleActionServer
 * @brief 圆周运动动作服务器类
 * 
 * 继承自rclcpp::Node，作为动作服务器，负责：
 * 1. 接收客户端动作目标请求
 * 2. 执行圆周运动模拟
 * 3. 周期性发布进度反馈
 * 4. 返回最终执行结果
 */

class MoveCircleActionServer : public rclcpp::Node
{
    public:
        // 定义一个自定义的动作接口类，便于后续使用
        using CustomAction = learning_interface::action::MoveCircle;
        // 定义一个处理动作请求、取消、执行的服务器端
        using GoalHandle = rclcpp_action::ServerGoalHandle<CustomAction>;

         /**
         * @brief 构造函数，初始化动作服务器
         * @param action_server_options 节点选项
         * 
         * 主要工作：
         * 1. 初始化ROS2节点
         * 2. 创建动作服务器
         * 3. 绑定三个核心回调函数
         */

        // 调用父类构造函数，设置节点名        
        explicit MoveCircleActionServer(const rclcpp::NodeOptions & action_server_options = rclcpp::NodeOptions())
        : Node("action_move_server", action_server_options)                                     // ROS2节点父类初始化
        {
            using namespace std::placeholders; // 用于_1, _2占位符

            // 创建动作服务器 - ROS2 Action的核心组件
            // 参数说明：
            // 1. this: 当前节点指针
            // 2. "move_circle": 动作名称（客户端通过此名称找到服务器）
            // 3. handle_goal: 目标请求回调函数（验证目标有效性）
            // 4. handle_cancel: 取消请求回调函数（处理客户端取消）
            // 5. handle_accepted: 目标接受回调函数（开始执行任务）
            this->action_server_ = rclcpp_action::create_server<CustomAction>(                  // 创建动作服务器（接口类型、动作名、回调函数）
                // 可以这样简化: "this" to replace below...
                // this->get_node_base_interface(), // 节点基础接口
                // this->get_node_clock_interface(),     // 时钟接口
                // this->get_node_logging_interface(),  // 日志接口
                // this->get_node_waitables_interface(),    // 可等待对象接口
                this,   // 当前节点
                "move_circle",      // 动作名称
                std::bind(&MoveCircleActionServer::handle_goal, this, _1, _2),
                std::bind(&MoveCircleActionServer::handle_cancel, this, _1),
                std::bind(&MoveCircleActionServer::handle_accepted, this, _1));

            // 日志输出，提示服务器已启动
            RCLCPP_INFO(this->get_logger(), " Server:  圆周运动动作服务器已启动");
            RCLCPP_INFO(this->get_logger(), " Server:  正在等待客户端发送目标...");
        }

    private:
        // 动作服务器智能指针（ROS2对象通常使用智能指针管理）
        rclcpp_action::Server<CustomAction>::SharedPtr action_server_;  // 动作服务器

        /**
         * @brief 处理动作目标请求的回调函数
         * @param uuid 目标的唯一标识符（自动生成）
         * @param goal_request 客户端发送的目标请求
         * @return GoalResponse 告诉客户端是否接受目标
         * 
         * 调用时机：客户端发送新目标后立即调用
         * 主要作用：验证目标是否有效，决定接受或拒绝
         */

        // 响应动作目标的请求
        rclcpp_action::GoalResponse handle_goal(
            const rclcpp_action::GoalUUID & uuid,   // 目标UUID，唯一标识
            std::shared_ptr<const CustomAction::Goal> goal_request)   // 客户端的目标请求                          
        {
            RCLCPP_INFO(this->get_logger(), "Server: 回调: 收到目标请求: enable=%d", goal_request->enable);
             (void)uuid; // 避免"未使用参数"的编译器警告

            // 验证目标：检查enable字段是否为true
            // 这是业务逻辑验证，例如检查参数是否合理
            if (goal_request->enable)                                                           
            {
                RCLCPP_INFO(this->get_logger(), "Server: 回调: 目标验证通过，接受请求");
                return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
            }
            else
            {
                RCLCPP_WARN(this->get_logger(), "Server: 回调: 目标验证失败：enable必须为true");
                return rclcpp_action::GoalResponse::REJECT;
            }
        }

          /**
         * @brief 处理取消请求的回调函数
         * @param goal_handle 客户端请求取消的目标句柄
         * @return CancelResponse 告诉客户端是否允许取消
         * 
         * 调用时机：客户端请求取消正在执行的动作时
         * 主要作用：执行取消逻辑，清理资源
         */

        // 响应动作取消的请求
        rclcpp_action::CancelResponse handle_cancel(
            const std::shared_ptr<GoalHandle> goal_handle_canceled_)                            
        {
            RCLCPP_INFO(this->get_logger(), "Server: 回调: 收到取消请求");
            (void) goal_handle_canceled_;   // 避免未使用参数警告
            // 这里可以添加取消逻辑，如：
            // 1. 停止电机运动
            // 2. 清理临时数据
            // 3. 记录取消日志
            
            // 接受取消请求
            return rclcpp_action::CancelResponse::ACCEPT;
        }

         /**
         * @brief 处理已接受目标的回调函数
         * @param goal_handle 已被接受的目标句柄
         * 
         * 调用时机：handle_goal返回ACCEPT后立即调用
         * 主要作用：启动新线程执行长时间任务，避免阻塞服务器
         * 
         * 关键点：为什么在新线程执行？
         * - Action通常执行长时间任务（秒/分钟级）
         * - 如果在主线程执行，会阻塞其他回调函数
         * - 使用线程可以实现并行处理多个目标
         */

        // 处理动作接受后具体执行的过程
        void handle_accepted(const std::shared_ptr<GoalHandle> goal_handle_accepted_)          
        {
             // 输出日志，提示开始执行
            RCLCPP_INFO(this->get_logger(), "Server: 回调: 目标已被接受，开始执行...");

            using namespace std::placeholders; 
            // 在线程中执行动作过程
            std::thread{std::bind(&MoveCircleActionServer::execute, this, _1), goal_handle_accepted_}.detach();     // detach()使线程独立运行，不阻塞主线程
        }

        /**
         * @brief 执行圆周运动的核心函数
         * @param goal_handle 目标句柄，用于发布反馈和返回结果
         * 
         * 这是实际的业务逻辑实现：
         * 1. 模拟圆周运动（0°→360°，每步30°）
         * 2. 每步发布进度反馈
         * 3. 检查是否被取消
         * 4. 完成后返回结果
         */

        void execute(const std::shared_ptr<GoalHandle> goal_handle_)
        {
            const auto requested_goal = goal_handle_->get_goal();       // 动作目标
            auto feedback = std::make_shared<CustomAction::Feedback>(); // 动作反馈
            auto result = std::make_shared<CustomAction::Result>();     // 动作结果

            RCLCPP_INFO(this->get_logger(), "Server: 回调: 开始执行圆周运动模拟...");
            rclcpp::Rate loop_rate(1);

            // 圆周运动模拟：从0°到360°，每次增加30°
            // 角度循环，模拟圆周运动进度
            // 动作执行的过程
            for (int i = 0; (i < 361) && rclcpp::ok(); i=i+30)
            {
                // 检查是否取消动作
                if (goal_handle_->is_canceling())
                {
                    result->finish = false;
                    goal_handle_->canceled(result);
                    RCLCPP_INFO(this->get_logger(), "Server: 回调: 检测到取消请求，停止执行");
                    return;
                }

                // 更新反馈状态
                feedback->state = i;    // 设置当前角度
                // 发布反馈状态,反馈给客户端
                goal_handle_->publish_feedback(feedback);
                RCLCPP_INFO(this->get_logger(), "Server: 回调: 发布进度反馈: %d°", i);

                // loop_rate.sleep();
                // 模拟运动耗时（实际机器人这里会控制电机）
                // 休眠300毫秒，模拟30°运动所需时间
                std::this_thread::sleep_for(std::chrono::milliseconds(300));
            }

            // 动作执行完成
            if (rclcpp::ok())
            {
                result->finish = true;   // 设置结果为完成
                goal_handle_->succeed(result);   // 通知客户端执行成功
                RCLCPP_INFO(this->get_logger(), "Server: 回调:圆周运动执行完成");
            }
        }
};

/**
 * @brief 主函数 - ROS2节点入口点
 * @param argc 命令行参数数量
 * @param argv 命令行参数数组
 * @return int 程序退出码
 * 
 * ROS2 C++程序的标准结构：
 * 1. 初始化ROS2
 * 2. 创建节点
 * 3. 进入事件循环
 * 4. 清理资源
 */

// ROS2节点主入口main函数
int main(int argc, char * argv[])                                
{
    // ROS2 C++接口初始化
    rclcpp::init(argc, argv);                        
    
    // 创建ROS2节点对象并进行初始化             
    rclcpp::spin(std::make_shared<MoveCircleActionServer>());   
    
    // 关闭ROS2 C++接口  
    rclcpp::shutdown();                                           
    
    return 0;
}

``` 
</details>

---  

<details>
  <summary> <mark>全部带注释action_move_client代码</mark></summary>  

```c++
/***
 * @file action_move_client.cpp
 * @brief ROS2动作示例 - 圆周运动动作客户端
 * @details
 * Action客户端用于向服务器发送目标请求，并异步接收：
 * 1. 目标响应（接受/拒绝） - 立即
 * 2. 进度反馈（周期性） - 执行过程中
 * 3. 最终结果（成功/失败） - 执行完成后
 * 
 * 这种设计使客户端可以：
 * - 非阻塞方式启动长时间任务
 * - 实时监控任务进度
 * - 必要时取消任务
 ***/

#include <iostream>
#include <memory>           // 智能指针库
#include <future>           // 异步操作支持

#include "rclcpp/rclcpp.hpp"                          // ROS2 C++接口库
#include "rclcpp_action/rclcpp_action.hpp"            // ROS2 动作类
#include "learning_interface/action/move_circle.hpp"  // 自定义的圆周运动接口

using namespace std;

/**
 * @class MoveCircleActionClient
 * @brief 圆周运动动作客户端类
 * 
 * 负责与动作服务器交互：
 * 1. 连接动作服务器
 * 2. 发送动作目标
 * 3. 处理服务器的三种响应
 * 4. 提供用户反馈
 */
class MoveCircleActionClient : public rclcpp::Node
{
    public:
        // 定义一个自定义的动作接口类，便于后续使用
        using CustomAction = learning_interface::action::MoveCircle;
        // 定义一个处理动作请求、取消、执行的客户端类
        using GoalHandle = rclcpp_action::ClientGoalHandle<CustomAction>;

        /**
        * @brief 构造函数，初始化动作客户端
        */
        explicit MoveCircleActionClient(const rclcpp::NodeOptions & node_options = rclcpp::NodeOptions())
        : Node("action_move_client", node_options)                            // ROS2节点父类初始化
        {
            this->client_ptr_ = rclcpp_action::create_client<CustomAction>(   // 创建动作客户端（接口类型、动作名）
                // this->get_node_base_interface(),
                // this->get_node_graph_interface(),
                // this->get_node_logging_interface(),
                // this->get_node_waitables_interface(),
                this,           // 直接传节点指针
                "move_circle");
            
            RCLCPP_INFO(this->get_logger(), "  圆周运动动作客户端已创建");
            RCLCPP_INFO(this->get_logger(), "   正在等待服务器上线...");
        }

        /**
         * @brief 发送动作目标到服务器
         * @param enable 是否启用圆周运动
         * 
         * 客户端的主功能函数，执行流程：
         * 1. 等待服务器上线
         * 2. 设置回调函数
         * 3. 异步发送目标
         */
        // 创建一个发送动作目标的函数
        void send_goal(bool enable)
        {
            // 第一步：等待服务器上线（最长10秒）
            // wait_for_action_server：阻塞等待，直到服务器可用或超时
            // 检查动作服务器是否可以使用
            if (!this->client_ptr_->wait_for_action_server(std::chrono::seconds(10))) 
            {
                RCLCPP_ERROR(this->get_logger(), "Client: 错误：动作服务器10秒内无响应");
                rclcpp::shutdown();
                return; // 服务器未响应，直接返回
            }

            // 第二步：创建目标消息
            // 绑定动作请求、取消、执行的回调函数
            auto send_goal_options = rclcpp_action::Client<CustomAction>::SendGoalOptions();
            using namespace std::placeholders;
            
            // 1. 目标响应回调 - 服务器立即响应（接受/拒绝目标）
            send_goal_options.goal_response_callback =
                std::bind(&MoveCircleActionClient::goal_response_callback, this, _1);
            // 2. 反馈回调 - 周期性接收进度更新
            send_goal_options.feedback_callback =
                std::bind(&MoveCircleActionClient::feedback_callback, this, _1, _2);
            // 3. 结果回调 - 接收最终执行结果
            send_goal_options.result_callback =
                std::bind(&MoveCircleActionClient::result_callback, this, _1);

            // 创建一个动作目标的消息
            auto goal_msg = CustomAction::Goal();
            goal_msg.enable = enable;
            RCLCPP_INFO(this->get_logger(), "准备发送目标：enable=%d", goal_msg.enable);

            // 异步方式发送动作的目标
            RCLCPP_INFO(this->get_logger(), "正在异步发送目标到服务器...");
                this->client_ptr_->async_send_goal(goal_msg, send_goal_options);
        }

    private:
        rclcpp_action::Client<CustomAction>::SharedPtr client_ptr_;

        /************************ 三个核心回调函数 ************************/  
        /**
         * @brief 目标响应回调函数（第一层回调）
         * @param future 包含服务器响应的future对象
         * 
         * 调用时机：服务器收到目标后几毫秒内调用
         * 主要作用：处理服务器的初始决策（接受/拒绝目标）
         * 
         * 类比：打电话给餐厅订位，接线员立即回复"有位子"或"已满座"
         */
        
        // 创建一个服务器收到目标之后反馈时的回调函数
        void goal_response_callback(GoalHandle::SharedPtr goal_message)
		{
            // 检查目标是否被接受
			if (!goal_message)
			{
				RCLCPP_ERROR(this->get_logger(), "Client: 回调: 服务器拒绝了我们的目标请求");
				rclcpp::shutdown(); // Shut down client node
			}
			else
			{
				RCLCPP_INFO(this->get_logger(), "Client: 回调: 服务器接受了我们的目标, waiting for result");
			}
		}

        /**
         * @brief 反馈回调函数（第二层回调）
         * @param goal_handle 目标句柄（标识哪个目标）
         * @param feedback 服务器发送的反馈消息
         * 
         * 调用时机：服务器执行过程中定期调用（本示例每300ms一次）
         * 主要作用：接收实时进度更新，可用于：
         * 1. 更新用户界面进度条
         * 2. 记录执行日志
         * 3. 判断是否超时
         * 
         * 类比：外卖配送中，骑手定期报告"已取餐"、"到XX路口"、"还有5分钟"
         */
            // 创建处理周期反馈消息的回调函数
        void feedback_callback(
            GoalHandle::SharedPtr,
            const std::shared_ptr<const CustomAction::Feedback> feedback_message)
        {
            std::stringstream ss;
            ss << "Client: 回调: 收到进度更新: "<< feedback_message->state;
            RCLCPP_INFO(this->get_logger(), "%s", ss.str().c_str());

            // 这里可以添加更多处理逻辑，例如：
            // 1. 计算进度百分比
            // int progress = (feedback->state * 100) / 360;
            // 2. 检查是否卡住（长时间进度不变）
            // 3. 更新GUI进度条
        }


         /**
         * @brief 结果回调函数（第三层回调）
         * @param result 包含最终结果的包装对象
         * 
         * 调用时机：动作执行完成后调用（一次性）
         * 主要作用：处理最终执行结果，进行清理工作
         * 
         * 结果可能的状态：
         * 1. SUCCEEDED - 成功完成
         * 2. ABORTED - 执行失败（服务器内部错误）
         * 3. CANCELED - 被用户取消
         * 4. UNKNOWN - 未知错误
         * 
         * 类比：外卖送达后，收到"订单已完成"的最终通知
         */
            // 创建一个收到最终结果的回调函数
        void result_callback(const GoalHandle::WrappedResult & result_message)
        {
            switch (result_message.code)
            {
                case rclcpp_action::ResultCode::SUCCEEDED:
                    break;
                case rclcpp_action::ResultCode::ABORTED:
                    RCLCPP_ERROR(this->get_logger(), "Client: 回调: Goal was aborted");
                    rclcpp::shutdown(); // 关闭客户端节点
                    return;
                case rclcpp_action::ResultCode::CANCELED:
                    RCLCPP_ERROR(this->get_logger(), "Client: 回调:  Goal was canceled");
                    rclcpp::shutdown(); // 关闭客户端节点
                    return;
                default:
                    RCLCPP_ERROR(this->get_logger(), "Client: 回调: Unknown result code");
                    rclcpp::shutdown(); // 关闭客户端节点
                    return;
            }
            RCLCPP_INFO(this->get_logger(), "Client: 回调: Result received: %s", (result_message.result->finish ? "true" : "false"));
            
            RCLCPP_INFO(this->get_logger(), "Client: 回调: 动作执行流程全部结束");
            rclcpp::shutdown();         // 关闭客户端节点
        }
};

// ROS2节点主入口main函数
int main(int argc, char * argv[])                                    
{
    // ROS2 C++接口初始化
    rclcpp::init(argc, argv);   
    
    // 创建一个客户端指针                                     
    auto action_client = std::make_shared<MoveCircleActionClient>(); 
    
    // 发送动作目标
    action_client->send_goal(true);     
    
    // 创建ROS2节点对象并进行初始化                            
    rclcpp::spin(action_client);  
    
    // 关闭ROS2 C++接口                                   
    rclcpp::shutdown();                                              
    
    return 0;
}

```
</details>

---

在colcon build编译完成后，后续则可以进行测试：   
`ros2 run learning_action_cpp action_move_server`  
`ros2 run learning_action_cpp action_move_client`
