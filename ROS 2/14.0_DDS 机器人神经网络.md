# DDS：Data Distribution Service 数据为中心模式

---
## qos : quality of service

在代码中，  
`ros2 topic pub /chatter std_msgs/msg/Int32 "data: 31" --qos- #之后可以用tab来补全，看看有哪些东西可用`  
其中有--qos-depth;; --qos-durability;; --qos-history;; --qos-profile;; --qos-reliability;;    
|配置项|选项|说明|
|:--|:--|:--|
|可靠性 (Reliability)|`RELIABLE`<br>`BEST_EFFORT`|保证消息送达，可能重传，延迟较高<br>尽最大努力，不保证送达，延迟较低|
|历史策略 (History)|`KEEP_LAST`<br>`KEEP_ALL`|只保留最新的N条消息<br>保留所有消息，直到资源耗尽|
|队列深度 (Depth)|整数数字|`KEEP_LAST`时保留的消息数量|
|持久性 (Durability)|`VOLATILE`<br>`TRANSIENT_LOCAL`|默认，不持久化<br>新订阅者能收到最后一条消息|
---

在ros2中，命令行中配置DDS：  
`ros2 topic pub /chatter std_msgs/msg/Int32 "data: 31" --qos-reliability best_effort # 这是publisher`   
`ros2 topic echo --qos-reliability best_effort #如果不是相同的传输模式会报错，无法收到消息`   
或者：  
`ros2 topic info /chatter --verbose  # 这个代码可以查看发布者的相关 qos profile 信息设置`  

---
首先，并没有 learning_qos_cpp 这个文件夹：  
`cd ~/dev_ws/src`  
`ros2 pkg create learning_qos_cpp --build-type ament_cmake --dependencies rclcpp std_msgs`  
然后再添加cpp文件，以及修改CMakeLists.txt 以及 package.xml文件

---

pwd: /learning_qos_cpp/src/qos_helloworld_pub.cpp  

<details>
<summary> <mark> qos_helloworld_pub.cpp 全部代码 </mark></summary>

```c++
/**
 * @file qos_helloworld_pub.cpp
 * @brief QoS示例 - 发布者节点
 * @details 演示如何在C++中配置QoS策略，控制消息传输的可靠性、历史记录和队列深度
 */

#include <chrono>
#include <memory>
#include <string>

#include "rclcpp/rclcpp.hpp"        // ROS2 C++核心库
#include "std_msgs/msg/string.hpp"  // 字符串消息类型

using namespace std::chrono_literals;

/**
 * @class QoSPublisherNode
 * @brief QoS发布者节点类
 * 
 * 演示如何使用不同的QoS策略发布消息：
 * 1. 可靠性策略：RELIABLE（可靠）或BEST_EFFORT（尽力而为）
 * 2. 历史策略：KEEP_ALL（保留所有）或KEEP_LAST（保留最后N个）
 * 3. 队列深度：历史记录的数量
 */
class QoSPublisherNode : public rclcpp::Node
{
public:
    QoSPublisherNode() : Node("qos_helloworld_pub")
    {
        // ==================== QoS配置 ====================
        // 创建QoS配置对象
        // 方法1：使用rclcpp::QoS类（推荐）
        rclcpp::QoS qos_profile(10);  // 参数10表示队列深度
        
        // 设置可靠性策略
        // - RELIABLE: 保证消息送达，可能有重传延迟
        // - BEST_EFFORT: 尽最大努力送达，不保证，但延迟低
        qos_profile.reliability(rclcpp::ReliabilityPolicy::Reliable);
        // qos_profile.reliability(rclcpp::ReliabilityPolicy::BestEffort); // 另一种选择
        
        // 设置持久性策略（默认是VOLATILE）
        // qos_profile.durability(rclcpp::DurabilityPolicy::TransientLocal);
        
        // 设置历史策略
        // - KEEP_ALL: 保留所有消息（直到队列满）
        // - KEEP_LAST: 只保留最近的N个消息（N=队列深度）
        qos_profile.history(rclcpp::HistoryPolicy::KeepLast);
        
        // 设置队列深度（历史策略为KEEP_LAST时有效）
        qos_profile.keep_last(10);
        
        // 可选：设置截止时间、生命周期等高级QoS策略
        // qos_profile.deadline(std::chrono::milliseconds(100));
        // qos_profile.lifespan(std::chrono::seconds(5));
        // qos_profile.liveliness(rclcpp::LivelinessPolicy::Automatic);
        // qos_profile.liveliness_lease_duration(std::chrono::seconds(2));
        
        // ==================== 创建发布者 ====================
        // 使用配置好的QoS创建发布者
        publisher_ = this->create_publisher<std_msgs::msg::String>(
            "chatter",      // 话题名称
            qos_profile     // QoS配置
        );
        
        // ==================== 创建定时器 ====================
        // 每500ms发布一次消息
        timer_ = this->create_wall_timer(
            500ms,  // 时间间隔
            std::bind(&QoSPublisherNode::timer_callback, this)
        );
        
        // ==================== 输出配置信息 ====================
        RCLCPP_INFO(this->get_logger(), "QoS发布者节点已启动");
        RCLCPP_INFO(this->get_logger(), "  话题: chatter");
        RCLCPP_INFO(this->get_logger(), "  频率: 2Hz (500ms)");
        RCLCPP_INFO(this->get_logger(), "  QoS策略:");
        RCLCPP_INFO(this->get_logger(), "    - 可靠性: %s", 
                   (qos_profile.reliability() == rclcpp::ReliabilityPolicy::Reliable) 
                   ? "RELIABLE" : "BEST_EFFORT");
        RCLCPP_INFO(this->get_logger(), "    - 历史策略: %s", 
                   (qos_profile.history() == rclcpp::HistoryPolicy::KeepLast) 
                   ? "KEEP_LAST" : "KEEP_ALL");
        RCLCPP_INFO(this->get_logger(), "    - 队列深度: %d", qos_profile.depth());
    }

private:
    // 定时器回调函数
    void timer_callback()
    {
        // 创建消息对象
        auto msg = std_msgs::msg::String();
        msg.data = "Hello World";
        
        // 发布消息
        publisher_->publish(msg);
        
        // 输出日志
        RCLCPP_INFO(this->get_logger(), "发布消息: '%s'", msg.data.c_str());
    }
    
    // 成员变量
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
    rclcpp::TimerBase::SharedPtr timer_;
};

/**
 * @brief 主函数
 */
int main(int argc, char* argv[])
{
    // 初始化ROS2
    rclcpp::init(argc, argv);
    
    // 创建节点并运行
    auto node = std::make_shared<QoSPublisherNode>();
    rclcpp::spin(node);
    
    // 关闭ROS2
    rclcpp::shutdown();
    
    return 0;
}
```

</details>

---

pwd: /learning_qos_cpp/src/qos_helloworld_sub.cpp  

<details>
<summary> <mark> qos_helloworld_sub.cpp 全部代码 </mark></summary>

```c++
/**
 * @file qos_helloworld_sub.cpp
 * @brief QoS示例 - 订阅者节点
 * @details 订阅者必须使用与发布者兼容的QoS策略才能成功接收消息
 *          如果不兼容，ROS2会发出警告，消息可能无法传递
 */

#include <memory>
#include <string>

#include "rclcpp/rclcpp.hpp"        // ROS2 C++核心库
#include "std_msgs/msg/string.hpp"  // 字符串消息类型

using std::placeholders::_1;

/**
 * @class QoSConsumerNode
 * @brief QoS消费者节点类
 * 
 * 演示如何配置订阅者的QoS策略，必须与发布者的QoS兼容才能接收消息
 */
class QoSConsumerNode : public rclcpp::Node
{
public:
    QoSConsumerNode() : Node("qos_helloworld_sub")
    {
        // ==================== QoS配置 ====================
        // 创建QoS配置对象
        rclcpp::QoS qos_profile(10);  // 队列深度
        
        // 设置可靠性策略（必须与发布者匹配或更宽松）
        // 订阅者的可靠性策略不能比发布者更严格
        // - 如果发布者是RELIABLE，订阅者可以是RELIABLE或BEST_EFFORT
        // - 如果发布者是BEST_EFFORT，订阅者必须是BEST_EFFORT
        qos_profile.reliability(rclcpp::ReliabilityPolicy::Reliable);
        
        // 设置历史策略
        qos_profile.history(rclcpp::HistoryPolicy::KeepLast);
        
        // 设置队列深度
        qos_profile.keep_last(10);
        
        // ==================== 创建订阅者 ====================
        // 使用配置好的QoS创建订阅者
        subscription_ = this->create_subscription<std_msgs::msg::String>(
            "chatter",        // 话题名称
            qos_profile,      // QoS配置
            std::bind(&QoSConsumerNode::message_callback, this, _1)
        );
        
        // ==================== 输出配置信息 ====================
        RCLCPP_INFO(this->get_logger(), "QoS订阅者节点已启动");
        RCLCPP_INFO(this->get_logger(), "  订阅话题: chatter");
        RCLCPP_INFO(this->get_logger(), "  QoS策略:");
        RCLCPP_INFO(this->get_logger(), "    - 可靠性: %s", 
                   (qos_profile.reliability() == rclcpp::ReliabilityPolicy::Reliable) 
                   ? "RELIABLE" : "BEST_EFFORT");
        RCLCPP_INFO(this->get_logger(), "    注意：RELIABLE订阅者只能接收RELIABLE发布者的消息");
        RCLCPP_INFO(this->get_logger(), "    如果发布者使用BEST_EFFORT，将收不到消息！");
    }

private:
    // 消息回调函数
    void message_callback(const std_msgs::msg::String::SharedPtr msg)
    {
        // 处理接收到的消息
        RCLCPP_INFO(this->get_logger(), "收到消息: '%s'", msg->data.c_str());
    }
    
    // 成员变量
    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
};

/**
 * @brief 主函数
 */
int main(int argc, char* argv[])
{
    // 初始化ROS2
    rclcpp::init(argc, argv);
    
    // 创建节点并运行
    auto node = std::make_shared<QoSConsumerNode>();
    rclcpp::spin(node);
    
    // 关闭ROS2
    rclcpp::shutdown();
    
    return 0;
}
```

</details>

---

CMakeLists中添加：  
```cmake
# 在已有配置的基础上，添加以下内容：
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)

# 1. 添加新的可执行文件（在已有的add_executable附近添加）
add_executable(new_node              # 可执行文件名
  src/new_node.cpp                   # 源文件路径
)

# 2. 为新节点指定依赖库（在已有的ament_target_dependencies附近添加）
ament_target_dependencies(new_node   # 与add_executable的第一个参数一致
  rclcpp
  std_msgs                           # 根据你的需要添加
  # 其他依赖...
)

# 3. 安装可执行文件（在install部分添加）
# 找到 install(TARGETS ...) 部分，在列表中添加 new_node
install(TARGETS
  # 已有的可执行文件...
  new_node                           # 添加这一行
  DESTINATION lib/${PROJECT_NAME}
)
```

---
package 中添加：  
```xml
<!-- 只需要基础的ROS2依赖 -->
<depend>rclcpp</depend>
<depend>std_msgs</depend>
```
---

之后就可以使用  
`ros2 run learning_qos_cpp qos_helloworld_pub`  
`ros2 run learning_qos_cpp qos_helloworld_sub`  
以及查看QoS信息  
```c++
# 查看节点的QoS配置
ros2 topic info /chatter --verbose

# 查看所有话题的QoS信息
ros2 topic list -t

# 查看节点间的兼容性
ros2 doctor --report
```


